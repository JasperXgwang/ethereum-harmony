#
# Config for connecting to Private network
# This file suites as placeholder for overriding default properties
#
# Full description of possible properties could be found in EthereumJ project
# https://github.com/ethereum/ethereumj/blob/master/ethereumj-core/src/main/resources/ethereumj.conf
#

peer.discovery = {
  # Disabling discovery for this self mining node
  enabled = false

  external.ip = "172.17.140.61"
  bind.ip = "172.17.140.61"

  //  external.ip = "172.16.187.143"
  //  bind.ip = "172.16.187.143"

  #don't persist peer stats
  persist = false

  # List of the seed peers to start
  # the search for online peers
  # values: [ip:port, enode://nodeid@ip:port, ip:port ...]
  //  values:["enode://75dc6d5c3eb72f6413446908ba59403780e5e3c9bb4d45aa506227f559133f7e161588ae8368b66513d69047820de1c87d415ad170d3a636be8fa98bec0d41ba@172.16.187.143:30303"]
  //  ip.list = [
  //    "172.16.187.143:30303"
  //  ]

}

# the folder resources/genesis
# contains several versions of
# genesis configuration according
# to the network the peer will run
genesis = genesis-private.json

peer {
  # Port on which ethereumj will listen
  # for incoming connections
  listen.port = 30303

  # Network id
  networkId = 111

  # Private key of the peer   jasper SHA-256
  # The key is generated by default on the first run and stored in the database folder
  # If you have your own peer ID, specify its private key here
  # derived nodeId = 75dc6d5c3eb72f6413446908ba59403780e5e3c9bb4d45aa506227f559133f7e161588ae8368b66513d69047820de1c87d415ad170d3a636be8fa98bec0d41ba
  # privateKey = 3721e1a2ad55f5ac10498a98a9069121be19ea3363cf44f18f10008728c360ad

  # Boot node list
  discovery.enabled = false
  active = [
    {url = "enode://75dc6d5c3eb72f6413446908ba59403780e5e3c9bb4d45aa506227f559133f7e161588ae8368b66513d69047820de1c87d415ad170d3a636be8fa98bec0d41ba@172.16.187.143:30303"},
    {url = "enode://a0c8f1f496c5e9f88cf79ad7d8359ad0f056c078678b6361561b6cc15a22403eff60b33ab9e12ce8163168703e19ec3e67c8f4fc41d4f4a15ae04671a2e9d5d3@172.17.140.61:30304"},
    {url = "enode://c8487563f43cc1f2545a04823367d95e0ad1bddda40a9c866f86f78643cf47e38d5b6d7efeeb9d813036851ddfbc01abd23d2263b286d4a3ebce978fe8dc34db@172.17.140.61:30303"}
  ]

  # list of trusted peers from which incoming connections are always accepted
  trusted = [
    # Sample entries:
    # {nodeId = "e437a4836b77ad9d9ffe73ee782ef2614e6d8370fcf62191a6e488276e23717147073a7ce0b444d485fff5a0c34c4577251a7a990cf80d8542e21b95aa8c5e6c"},
    # {ip = "11.22.33.44"},
    # {ip = "11.22.33.*"},
    # {
    #   nodeId = "e437a4836b77ad9d9ffe73ee782ef2614e6d8370fcf62191a6e488276e23717147073a7ce0b444d485fff5a0c34c4577251a7a990cf80d8542e21b95aa8c5e6c"
    #   ip = "11.22.33.44"
    # }
    {nodeId = "75dc6d5c3eb72f6413446908ba59403780e5e3c9bb4d45aa506227f559133f7e161588ae8368b66513d69047820de1c87d415ad170d3a636be8fa98bec0d41ba"},
    {ip = "172.17.140.61"},
    {ip = "172.16.187.143"},
  ]

  # max number of active peers our node will maintain
  # extra peers trying to connect us will be dropped with TOO_MANY_PEERS message
  # the incoming connection from the peer matching 'peer.trusted' entry is always accepted
  maxActivePeers = 30

  # The protocols supported by peer
  # can be: [eth, shh, bzz]
  capabilities = [eth]

  # connection timeout for trying to
  # connect to a peer [seconds]
  connection.timeout = 2

  # how much time [seconds]
  # we will wait for a message
  # to arrive before closing the channel
  channel.read.timeout = 30

  p2p {
    # the default version outbound connections are made with
    # inbound connections are made with the version declared by the remote peer (if supported)
    # version = 4

    # max frame size in bytes when framing is enabled
    framing.maxSize = 32768

    # forces peer to send Handshake message in format defined by EIP-8,
    # see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-8.md
    eip8 = true
  }
}


database {
  # place to save physical storage files
  # can be either absolute or relative path
  dir = /data/eth/database/${database.name}

  # every time the application starts
  # the existing database will be
  # destroyed and all the data will be
  # downloaded from peers again [true/false]
  reset = false

  # If reset=true, every time the application
  # starts the database will reset itself to
  # this block number and sync again from there.
  # Set to 0 for a 'full' reset.
  resetBlock = 0

  # every time the application starts
  # existing database will be restored from latest backup
  # this option is supported by RocksDB only
  fromBackup = false

  # handling incompatible database version:
  #  * EXIT   - (default) show error in std out and exit by throwing Error
  #  * RESET  - clear database directory and continue working
  #  * IGNORE - continue working regardless possible issues
  # @since 1.4.0
  incompatibleDatabaseBehavior = EXIT

  # controls state database pruning
  # pruned state consumes much less disk space (e.g. 50G full and 1G pruned)
  # but the state can be restored only within last [maxDepth] blocks, all older
  # states are lost
  prune {
    enabled = false

    # controls how much last block states are not pruned
    # it is not recommneded to set this value below 192
    # as it can prevent rebranching from long fork chains
    #
    # NOTE: the bigger this value is the larger memory footprint pruning has,
    # here are some milstones to get the idea of how large it can be:
    #       192: 10 Mb
    #     1_000: 16 Mb
    #    10_000: 58 Mb
    #   100_000: 718 Mb
    # 1_000_000: 5658 Mb
    maxDepth = 50000
  }

  # defines a number of opened files by db instance
  # this number has significant impact on read amplification
  # on the other hand it can force exceeding of user's limit,
  # OS usually set it to 1024 for all applications
  maxOpenFiles = 512
}

sync {
  # block chain synchronization
  # can be: [true/false]
  enabled = true

  # Make long sync done (switch to short sync) in XX seconds
  # if all known blocks already downloaded.
  # Useful in private networks where auto-switch could fail.
  # Recommended value for private networks: 60 (seconds)
  #
  # Use this if you run Harmony in Private network with sync enabled
  # and no other active miner
  makeDoneByTimeout = 60
}

# Configure blockchain
# Here it is possible to control Frontier, Olympic, Homestead, Dao and other
# Blockchain configuration via `genesis.json` `config` field is also supported
blockchain.config.name = null
blockchain.config.class = "org.ethereum.config.blockchain.FrontierConfig"

# miner options
mine {

  # Start mining blocks
  # when 'sync.enabled' is true the mining starts when the sync is complete
  # else the mining will start immediately, taking the best block from database
  # (or genesis if no blocks exist yet)
  start = false

  # Coinbase address for storing block mining reward
  //    coinbase = "9f8D0B28FBfD9d5Dc85b81c5D7fc5b8782C4C856"
  coinbase = "0x04244b608E7B0d3Fc56438F8Ba1055a0FF778dcb"
  //    coinbase = "0x867bF7582E9E57814D9381b0882e3C3Eb226035e"

  # Extra data included in the mined block
  # one of two properties should be specified
  extraData = "EthereumJ powered"
  #extraDataHex = "0102abcd"

  # transactions with the gas price lower than this will not be
  # included in mined blocks
  # decimal number in weis
  minGasPrice = 1000000000  # 1 Gwei

  # minimal timeout between mined blocks
  minBlockTimeoutMsec = 0

  # number of CPU threads the miner will mine on
  # 0 disables CPU mining
  cpuMineThreads = 1

  # there two options for CPU mining 'light' and 'full'
  # 'light' requires only 16M of RAM but is much slower
  # 'full' requires 1G of RAM and possibly ~7min for the DataSet generation
  #   but is much faster during mining
  fullDataSet = true
}

# Load the blocks
# from a rlp lines  RLP格式序列化对象
# file and not for
# the net
//blocks.loader = "blocks.rlp"

